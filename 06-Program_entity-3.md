# 06 | 程序实体的那些事儿 （下）

## 问题：怎样判断一个变量的类型？

## 典型回答

答案是使用“类型断言”表达式。具体怎么写呢？

    value, ok := interface{}(container).([]string)

这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。

它包括了用来把container变量的值转换为空接口值的interface{}(container)。

以及一个用于判断前者的类型是否为切片类型 []string 的 .([]string)。

这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。

如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。

顺便提一下，这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。

但是这样的话，当判断为否时就会引发异常。

这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。

除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。

## 问题解析

正式说明一下，类型断言表达式的语法形式是 **x.(T)**。其中的x代表要被判断类型的那个值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。
所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。
如果container是某个接口类型的，那么这个类型断言表达式就可以是container.([]string)。这样看是不是清晰一些了？

在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。我在下个模块，会再讲接口及其实现类型的问题。现在你只要知道，**任何类型的值都可以很方便地被转换成空接口的值就行了**。

这里的具体语法是interface{}(x)，例如前面展示的interface{}(container)。

你可能会对这里的{}产生疑惑，为什么在关键字interface的右边还要加上这个东西？

** 请记住，一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。**

而空接口interface{}则代表了不包含任何方法定义的、空的接口类型。

再往答案的最右边看。圆括号中[]string是一个类型字面量。所谓类型字面量，就是用来表示数据类型本身的若干个字符。

## 知识扩展

### 1. 你认为类型转换规则中有哪些值得注意的地方？

首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。
类似的快刀斩乱麻规则还有：当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。

第二，虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）。
字符'�'的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。

并询问会得到什么？这可是完全不同的问题啊。由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是"�"。在实际工作中，我们在排查问题时可能会遇到�，你需要知道这可能是由于什么引起的。

第三个知识点是关于string类型与各种切片类型之间的互转的。
你先要理解的是，一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。
其次，一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符。

### 2. 什么是别名类型？什么是潜在类型？

我们可以用关键字type声明自定义的各种类型

    type MyString = string

Go 语言内建的基本类型中就存在两个别名类型。byte是uint8的别名类型，而rune是int32的别名类型。

    type MyString2 string // 注意，这里没有等号。

MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。

这种方式也可以被叫做对类型的再定义。我们刚刚把string类型再定义成了另外一个类型MyString2。

对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。潜在类型的含义是某个类型在本质上是哪个类型或者是哪个类型的集合。

潜在类型相同的不同类型的值之间是可以进行类型转换的。因此，MyString2类型的值与string类型的值可以使用类型转换表达式进行互转。

但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是MyString2和string。

另外，即使两个类型的潜在类型相同，**它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值**。

## 思考题

本篇文章的思考题有两个。

除了上述提及的那些，你还认为类型转换规则中有哪些值得注意的地方？
你能具体说说别名类型在代码重构过程中可以起到哪些作用吗？