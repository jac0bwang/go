# 18 if语句、for语句和switch语句

## 使用携带range子句的for语句时需要注意哪些细节？

```go
numbers1 := []int{1, 2, 3, 4, 5, 6}
for i := range numbers1 {
    if i == 3 {
        numbers1[i] |= i
    }
}
fmt.Println(numbers1)
```

在这条for语句中，**只有一个迭代变量i**。

range表达式的结果值可以是数组、数组的指针、切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。

对于不同种类的range表达式结果值，for语句的迭代变量的数量可以有所不同。就拿我们这里的numbers1来说，它是一个切片，那么迭**代变量就可以有两个**，右边的迭代变量代表当次迭代对应的某一个元素值，而左边的迭代变量则代表该元素值在切片中的索引值。

如果像本题代码中的for语句那样，只有一个迭代变量的情况意味着什么呢？这意味着，该迭代变量只会代表当次迭代对应的元素值的索引值。

当**只有一个迭代变量**的时候，**数组、数组的指针、切片和字符串**的**元素值**都是无处安放的，我们只能拿到按照从小到大顺序给出的一个个**索引值**。

切片与数组是不同的，前者是引用类型的，而后者是值类型的。

注意两点：

1. range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代；
2. range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值。

```go
// 示例2。
numbers2 := [...]int{1, 2, 3, 4, 5, 6}
maxIndex2 := len(numbers2) - 1
for i, e := range numbers2 {
        if i == maxIndex2 {
                numbers2[0] += e
        } else {
                numbers2[i+1] += e
        }
}
fmt.Println(numbers2)
fmt.Println()
// [7 3 5 7 9 11]

// 示例3。
numbers3 := []int{1, 2, 3, 4, 5, 6}
maxIndex3 := len(numbers2) - 1
for i, e := range numbers3 {
        if i == maxIndex3 {
                numbers3[0] += e
        } else {
                numbers3[i+1] += e
        }
}
fmt.Println(numbers3)
//[22 3 6 10 15 21]
```

## 问题 1：switch语句中的switch表达式和case表达式之间有着怎样的联系？

case表达式一般由case关键字和一个表达式列表组成，表达式列表中的多个表达式之间需要有英文逗号,分割，比如，上面代码中的case value1[0], value1[1]就是一个case表达式，其中的两个子表达式都是由索引表达式表示的。

只要switch表达式的结果值与某个case表达式中的任意一个子表达式的结果值相等，该case表达式所属的case子句就会被选中。

在 Go 语言中，只有类型相同的值之间才有可能被允许进行判等操作。

整数4的默认类型是int，又比如浮点数3.14的默认类型是float64。

如果case表达式中子表达式的结果值是无类型的常量，那么它的类型会被自动地转换为switch表达式的结果类型，又由于上述那几个整数都可以被转换为int8类型的值，所以对这些表达式的结果值进行判等操作是没有问题的。

由于需要进行判等操作，所以前者和后者中的子表达式的结果类型需要相同。

如果这些表达式的结果类型有某个接口类型，那么一定要小心检查它们的动态值是否都具有可比性（或者说是否允许判等操作）。因为，如果答案是否定的，虽然不会造成编译错误，但是后果会更加严重：引发 panic（也就是运行时恐慌）

## 问题 2：switch语句对它的case表达式有哪些约束？

同一条switch语句中的所有case表达式的子表达式的结果值不能重复，不过好在这只是对于由字面量直接表示的子表达式而言的。

## 思考题

1. 在类型switch语句中，我们怎样对被判断类型的那个值做相应的类型转换？
2. 在if语句中，初始化子句声明的变量的作用域是什么？