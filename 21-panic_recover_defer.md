# 21 panic函数、recover函数以及defer语句 （上）

程序异常被叫做 panic，我把它翻译为运行时恐慌。其中的“恐慌”二字是由 panic 直译过来的，而之所以前面又加上了“运行时”三个字，是因为这种异常只会在程序运行的时候被抛出来。

在这个 panic 中，包含了一个runtime.Error接口类型的值。runtime.Error接口内嵌了error接口并做了一点点扩展，runtime包中有不少它的实现类型。

“panic：”右边的内容，正是这个 panic 包含的runtime.Error类型值的字符串表示形式。

panic 详情中一般还会包含与它的引发原因有关的 goroutine 的代码执行信息。

在 Go 语言中，因 panic 导致程序结束运行的退出状态码一般都会是2。

## 从 panic 被引发到程序终止运行的大致过程是什么？

一个大致的过程：某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。

这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。

这里的最外层函数指的是go函数，对于主 goroutine 来说就是main函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。

随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。

Go 语言的内建函数panic是专门用于引发 panic 的。**panic函数使程序开发者可以在程序运行期间报告异常**。

## 一个函数怎样才能把 panic 转化为error类型值，并将其作为函数的结果值返回给调用方？

使用go中的类似try catch这样的语句，将异常捕获的异常转为相应的错误error就可以了