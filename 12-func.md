# 12 使用函数的正确姿势

函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。

而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。

```go
type Printer func(contents string) (n int, err error)

func printToStd(contents string) (bytesNum int, err error) {
    return fmt.Println(contents)
}

func main() {
    var p Printer
    p = printToStd
    p("something")
}
```

先声明了一个函数类型，名叫Printer。注意这里的写法，在类型声明的名称右边的是func关键字，我们由此就可知这是一个函数类型的声明。在func右边的就是这个函数类型的参数列表和结果列表。

这里书写函数签名的方式与函数声明的是一致的。只是紧挨在参数列表左边的不是函数名称，而是关键字func。这里函数名称和func互换了一下位置而已。

函数的签名其实就是函数的参数列表和结果列表的统称，它定义了可用来鉴别不同函数的那些特征，同时也定义了我们与函数交互的方式。

只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了同一个函数类型的函数。

## 怎样编写高阶函数？

什么是高阶函数？

1. 接受其他的函数作为参数传入；
2. 把其他的函数作为结果返回。

高阶函数也是函数式编程中的重要概念和特征。

## 问题 1：如何实现闭包？

闭包又是什么？你可以想象一下，在一个函数中存在对外来标识符的引用。所谓的外来标识符，既不代表当前函数的任何参数或结果，也不是函数内部声明的，它是直接从外边拿过来的。

还有个专门的术语称呼它，叫自由变量，可见它代表的肯定是个变量。实际上，如果它是个常量，那也就形成不了闭包了，因为常量是不可变的程序实体，而闭包体现的却是由“不确定”变为“确定”的一个过程。

我们说的这个函数（以下简称闭包函数）就是因为引用了自由变量，而呈现出了一种“不确定”的状态，也叫“开放”状态。也就是说，它的内部逻辑并不是完整的，有一部分逻辑需要这个自由变量参与完成，而后者到底代表了什么在闭包函数被定义的时候却是未知的。

## 问题 2：传入函数的那些参数值后来怎么样了？

原数组不会改变。为什么呢？原因是，所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。

由于数组是**值类型**，所以每一次复制都会拷贝它，以及它的所有元素值。

注意，对于**引用类型**，比如：**切片、字典、通道**，像上面那样复制它们的值，只会拷贝它们本身而已，并**不会拷贝它们引用的底层数据**。也就是说，这时只是**浅表复制**，而不是深层复制。

以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。

另外还要注意，就算我们传入函数的是一个值类型的参数值，但如果这个参数值中的某个元素是引用类型的，那么我们仍然要小心。

## 思考题

1. complexArray1被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗？

    分2种情况，若是修改数组中的切片的某个元素，会影响原数组。若是修改数组的某个元素即a[1]=[]string{"x"}就不会影响原数组。谨记Go中都是浅拷贝，值类型和引用类型的区别

2. 函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？

    当函数返回指针类型时不会发生拷贝。当函数返回非指针类型并把结果赋值给其它变量肯定会发生拷贝