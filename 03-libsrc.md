# 03 库源码文件

库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）

1. 那么程序实体是什么呢？在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。
2. 总是会先声明（或者说定义）程序实体，然后再去使用
3. 程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字

## 问题：怎样把命令源码文件中的代码拆分到其他源码文件？

    在同一个目录下的源码文件都需要被声明为属于同一个代码包,如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包。源码文件声明的包名可以与其所在目录的名称不同，只要这些文件声明的包名一致就可以。

## 代码包声明的基本规则

第一条规则，**同目录下的源码文件的代码包声明语句要一致**。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。

第二条规则，**源码文件声明的代码包的名称可以与其所在的目录的名称不同**。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。
对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同，这在我前面的回答中也验证过了。

## 1. 怎样把命令源码文件中的代码拆分到其他代码包？  拆分方法

查看 ch3/q1/demo5  相关的代码, 对 demo5_lib.go 做了2处改动

第一个改动是，我把代码包声明语句由package main改为了package lib5。注意，我故意让声明的包名与其所在的目录的名称不同。

第二个改动是，我把全小写的函数名hello改为首字母大写的Hello

##　2. 代码包的导入路径总会与其所在目录的相对路径一致吗

库源码文件 demo5_lib.go 所在目录的相对路径是 ch3/q2/lib ，而它却声明自己属于 lib5 包。在这种情况下，该包的导入路径是 ch3/q2/lib，还是  ch3/q2/lib5？

```bash
$ go install ch3/q2/lib
$ ls pkg/linux_amd64/ch3/q2/lib.a
pkg/linux_amd64/ch3/q2/lib.a
```

再对 demo5.go 做2处改动：

第一个改动是，在以import为前导的代码包导入语句中加入 ch3/q2/lib，也就是试图导入这个代码包。

第二个改动是，把对hello函数的调用改为对lib.Hello函数的调用.其中的lib.叫做限定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不同，只包含了路径中的最后一级lib，这与代码包声明语句中的规则一致。

```bash
jacob@ubuntu:~/github/go/src/ch3/q2$ go run demo5.go
# command-line-arguments
./demo5.go:5:5: imported and not used: "ch3/q2/lib" as lib5
./demo5.go:16:2: undefined: lib
```

第一个错误提示的意思是，我们导入了 ch3/q2/lib 包，但没有实际使用其中的任何程序实体。这在 Go 语言中是不被允许的，在编译时就会导致失败。

这里还有另外一个线索，那就是“as lib5”。这说明虽然导入了代码包 ch3/q2/lib，但是使用其中的程序实体的时候应该以lib5.为限定符。这也就是第二个错误提示的原因了。Go 命令找不到lib.这个限定符对应的代码包。

根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同。请记住，源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应。

我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为package lib。理由是，为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。

## 3. 什么样的程序实体才可以被当前包外的代码引用？

为什么要把 demo5_lib.go 文件中的那个函数名称hello的首字母大写？实际上这涉及了 Go 语言中对于程序实体访问权限的规则。

名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。

通过名称，Go 语言自然地把程序实体的访问权限划分为了包级私有的和公开的。对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。

## 4. 对于程序实体，还有其他的访问权限规则吗？

答案是肯定的。在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：模块级私有。可以查看 q4 相关的代码

具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个internal包。对于其他代码包，导入该internal包都是非法的，无法通过编译。

1. 如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？
2. 如果会产生冲突，那么怎样解决这种冲突，有几种方式？

从go语言的规范来看有几种避免的方法：
Import declaration Local name of Sin

import "lib/math" math.Sin
import m "lib/math" m.Sin
import . "lib/math" Sin
import _ "lib/math"

可以通过包别名的方式解决冲突，如果导入的包不显式使用可以采用匿名的方式导入包