# 工作区和GOPATH

配置 3 个环境变量，即 GOROOT、GOPATH 和 GOBIN

## 设置 GOPATH 有什么意义？

环境变量 GOPATH 的值可以是一个目录的路径，也可以包含多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。这些工作区用于放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。

这个问题其实主要考察了 4 个知识点，分别是：

1. 你是否清楚 Go 语言源码的组织方式；
2. 你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使用）；
3. 你是否理解构建和安装 Go 程序的过程。这在开发程序以及查找程序问题的时候都很有用，否则你很可能会走弯路；
4. 你是否清楚 go build 命令的一些可选项的用途和用法，虽然有的集成开发环境已经为你选择好了。

## 1. Go 语言源码的组织方式

Go 语言的源码是以代码**包为基本组织单位**的。在文件系统中，这些**代码包其实是与目录一一对应**的。**目录可以有子目录，所以代码包也可以有子包**。

一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件**都需要被声明为属于同一个代码包**。代码包的名称一般会与这些源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会**以代码包名称为准**。

在工作区中，**一个代码包的导入路径**实际上就是**从 src 子目录，到该包的实际存储位置的相对路径**。所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。

## 2. 了解源码安装后的结果

源码文件以及安装后的结果文件都会放到哪里呢？我们都知道，源码文件通常会被放在某个工作区的 src 子目录下。

那么在安装后如果产生了归档文件，就会放进该工作区的 pkg 子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。

归档文件存放的具体位置和规则:

- 安装某个代码包而产生的归档文件是与这个代码包同名的
- 归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录.平台相关目录的名称是由 build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的

```BASH
#代码包的导入路径是
github.com/labstack/echo
#执行命令, 这个代码包导入路径还有另外一层含义:该代码包的源码文件存在于 GitHub 网站的 labstack 组的代码仓库 echo 中
go install github.com/labstack/echo
#代码包的归档文件就会被放置在当前工作区的子目录
pkg/linux_amd64/github.com/labstack
```

## 3. 理解构建和安装 Go 程序的过程

构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且这些操作生成的任何文件都会先被保存到某个临时的目录中。

go build

- 如果构建的是**库源码文件**，那么操作的结果文件只会存在于**临时目录中**。这里的构建的主要意义在于检查和验证。
- 如果构建的是**命令源码文件**，那么操作的结果文件会被搬运到那个**源码文件所在的目录中**。

go install

- 安装操作会**先执行构建**，然后还会**进行链接操作**，并且把结果文件搬运到指定目录。
- 如果安装的是**库源码文件**，那么结果文件会被搬运到它所在工作区的** pkg 目录下的某个子目录中**
- 如果安装的是**命令源码文件**，那么结果文件会被搬运到**它所在工作区的 bin 目录**中，或者**环境变量GOBIN指向的目录**中

## 4. go build 命令一些可选项的用途和用法

在运行go build命令的时候，**默认不会编译目标代码包所依赖的那些代码包**,如果被依赖的代码包的**归档文件不存在**，或者源码文件**有了变化**，那它还是会被编译。

```Bash
$ go help build

The -i flag installs the packages that are dependencies of the target.  
-a
    force rebuilding of packages that are already up-to-date.
-n
    print the commands but do not run them.
-x
    print the commands.
-v
    print the names of packages as they are compiled.
```

go get会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中.如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。

最常用的几个标记有下面几种

- -u：下载并安装代码包，不论工作区中是否已存在它们。
- -d：只下载代码包，不安装代码包。
- -fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。
- -t：同时下载测试所需的代码包。
- -insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。

有时候，我们可能会出于某种目的变更存储源码的代码仓库或者代码包的相对路径。这时，为了让代码包的远程导入路径不受此类变更的影响，我们会使用自定义的代码包导入路径。

对代码包的远程导入路径进行自定义的方法是：在该代码包中的库源码文件的包声明语句的右边加入导入注释

[go get 详细使用](https://github.com/hyper0x/go_command_tutorial/blob/master/0.3.md)

## 思考题

1. Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？

    例如 a 依赖 b ，b依赖c

    那么 会先查找c包，那在工作区是如何查找这个依赖包c的呢？

    首先在查找依赖包的时候，总是会先查找 GOROOT目录，也就是go语言的安装目录，如果没有找到依赖的包，才到工作区去找相应的包。

    在工作区中是按照设置的先后顺序来查找的，也就是会从第一个开始，依次查找，如果找到就不再继续查找，如果没有找到，就报错了。

    go get 会下载代码包到src目录，但是只会下载到第一个工作区目录。

    在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似"github.com/xxxx/tem"的字符串对应包的导入路径。

    Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。

    一个导入路径代表一个目录中的一个或多个Go源文件。

    除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。

2. 如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？

    不冲突，因为按顺序找到所需要的包就不往后找了。