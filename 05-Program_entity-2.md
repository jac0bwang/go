# 05 | 程序实体的那些事儿（中）

## 问题：如果一个变量与其外层代码块中的变量重名会出现什么状况？

具体的问题是：该源码文件中的代码能通过编译吗？如果不能，原因是什么？如果能，运行它后会打印出什么内容？

这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。

## 问题解析

这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。

首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。
一般情况下，程序会一直查到当前代码包代表的那层代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。

但有个特殊情况，如果我们把代码包导入语句写成import . XXX的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体被当前源码文件中的代码，视为当前代码包中的程序实体。

比如，如果有代码包导入语句import . fmt，那么我们在当前源码文件中引用fmt.Printf函数的时候直接用Printf就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。

## 知识扩展

不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？
把前者叫做“可重名变量”
变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间的由相同的标识符代表的变量。
变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
如果可重名变量所在的代码块之间存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

## 思考题

我们在讨论 Go 语言查找标识符时的范围的时候，提到过import . XXX这种导入代码包的方式。这里有个思考题：

如果通过这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go 语言是会把它们当做“可重名变量”看待还是会报错呢？

如果都是全局的变量，会报重复声明，如果只是在函数体重新声明，作用域不一样，不会报错,会出现屏蔽现象